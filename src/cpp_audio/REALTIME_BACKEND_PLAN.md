# Real-Time Audio Generation Backend Design

This document outlines a plan to create a high speed, real-time audio generation
backend in C++ that mirrors the functionality of the existing Python
`sound_creator.py` engine. The goal is to provide low-latency synthesis for
web-based meditation audio services while remaining compatible with track
JSON files produced by the GUI editor.

## Objectives

1. **Speed & Real-Time Performance**: Implement the core synthesis routines in C++
   using efficient DSP techniques and multi-threading. Target minimal latency for
   on-the-fly audio generation rather than offline rendering.
2. **Compatibility with Track JSON**: Parse the same JSON schema used by the
   Python generator so existing projects load without modification.
3. **Modular Synth Functions**: Provide C++ equivalents for the synths in
   `src/audio/synth_functions`, exposing a unified interface for adding new
   generators.
4. **Web Integration**: Expose the engine through a simple API that a web UI can
   control (e.g., start/stop, step preview, progress callbacks).
5. **Extensibility**: Keep the design modular to allow additional synthesis
   techniques or parameters in the future.

## Proposed Architecture

- **Core Engine (`core/`)**
  - `Track` and `StepModel` classes already exist for offline generation. Extend
    them to support streaming buffers rather than writing entire files to disk.
  - Introduce a `RealtimeSynthContext` responsible for managing sample rate,
    buffer size, and scheduling of steps.
  - Use a dedicated audio callback thread (via JUCE`s `AudioIODevice` or a
    similar library) to output samples in real time.

- **Synth Modules (`synths/`)**
  - Implement C++ versions of all Python synths (binaural beat, isochronic tone,
    etc.) using classes derived from a `SynthFunction` interface. Many of these
    already exist in `src/cpp_audio/synths` but lack real-time wrappers.
  - Each synth should provide a `process(float* left, float* right, int numSamples)`
    method to fill audio buffers on demand.

- **JSON Loader**
  - Add a parser (`TrackLoader.cpp`) that reads the GUI's JSON format into
    `Track`/`StepModel` objects. This ensures parity with the Python engine
    without rewriting the editor.

- **Web API Layer**
  - Create a thin C++ REST or WebSocket server (e.g., using Crow or cpp-httplib)
    that exposes endpoints to load a track, start/stop playback, and query
    status. This layer can run as a standalone service integrated with the web
    UI.

- **Integration Strategy**
  - Keep the Python generator for offline batch exports. The real-time C++
    backend will be compiled as a separate executable/library.
  - The web application communicates with the C++ backend over HTTP or WebSocket
    to control playback. Parameters like tempo or crossfade duration can be
    adjusted at runtime.

## Implementation Steps

1. **Define C++ Data Structures** ✅
   - Mirror the Python models (`Voice`, `Step`, `Track`) in the C++ `models/`
     directory. **Implemented:** added `TrackData.h` with structs mapping
     directly to the JSON schema and updated existing code to include this
     header.
   - Ensure all synth parameters (including transitions) map directly to their
     JSON names. **Done** by documenting JSON keys in comments for each
     struct field.

2. **Port Synth Functions**
   - Start with core generators (binaural, isochronic, AM) already present in the
     repository. Verify their outputs match the Python versions for identical
     parameters.
   - Implement missing functions and transition variants as needed.

3. **Real-Time Engine Prototype**
   - Build a JUCE-based application (`realtime_player.cpp`) that loads a track
     JSON and plays it through the system audio device.
   - Use a double-buffered approach: while one buffer is being sent to the audio
     device, the next buffer is generated by the synth chain.

4. **Web Service Wrapper**
   - Add an optional compile target that launches an HTTP/WebSocket server. Basic
     endpoints:
     - `POST /load` – upload/choose a track JSON
     - `POST /play` – begin playback
     - `POST /stop` – halt playback
     - `GET  /status` – query current position/state

5. **Testing & Validation**
   - Create unit tests comparing short segments generated by the C++ engine to
     those from the Python version to ensure feature parity.
   - Profile latency and CPU usage to verify real-time performance.

6. **Documentation**
   - Update `README_Audio.md` with build instructions for the new backend and
     example API usage from a web client.

## Notes

- JUCE is suggested for its cross-platform audio and networking capabilities, but
  other libraries (PortAudio + cpp-httplib) are viable if licensing or size is a
  concern.
- The existing C++ codebase already provides many building blocks (synth classes
  and GUI components). This plan focuses on adding streaming playback and a web
  control interface.
- Ensure thread safety when accessing track data from the audio callback.

