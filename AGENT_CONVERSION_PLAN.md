# C++ Conversion Plan for Audio Module using JUCE

This document outlines a high level plan for porting the current Python audio toolset in `src/audio` to a C++ application based on the JUCE framework.  The Python code uses PyQt5 for the GUI and NumPy/SciPy for DSP.  The goal is to replicate the functionality in a native desktop program that leverages JUCE for both the user interface and audio generation.

## 1. Explore Existing Python Code

* `src/audio/main.py` implements the **Binaural Track Editor** using PyQt5.  It loads and edits sequences, manages preferences and voices, and calls the synthesis engine.
* The core audio is produced in `src/audio/synth_functions/sound_creator.py`.  This script discovers available synthesis routines, mixes voices and overlay clips, applies crossfades and a limiter, then writes WAV/FLAC/MP3 output.  Voices are defined in separate functions (e.g. `binaural_beat`, `wave_shape_stereo_am`).  The README describes the generation workflow:

```
The `generate_audio` function orchestrates the process:
  1. Iterates through each step defined in the sequence.
  2. For each step, iterates through all defined voices.
  3. Calls the appropriate synth function (standard or transition) for each voice with its parameters.
  4. Mixes the audio generated by all voices within that step.
  5. Concatenates the audio from each step, applying a phase-aligned crossfade (curve selectable in Preferences, duration set in Global Settings) between steps to ensure smooth, artifact-free transitions.
  6. Applies a safety limiter to the final mixed track.
  7. Normalizes the audio to the Target Output Amplitude.
  8. Saves the result as a 16-bit stereo file.
```
* Models in `src/audio/models/models.py` expose data via PyQt table models.
* Utility modules under `src/audio/utils` manage preferences, timeline visualization and serialization of noise/voice presets.

## 2. Outline the JUCE-based Replacement

1. **Project Setup**
   - Create a new JUCE project using the Projucer tool or CMake.  Enable modules `juce_audio_basics`, `juce_audio_devices`, `juce_gui_basics`, `juce_gui_extra`, and `juce_audio_formats`.
   - Organize code with separate headers/sources for the synthesis engine, UI components, project model and serialization logic.

2. **Port the Data Model**
   - Translate the Python `StepModel` and `VoiceModel` to plain C++ structs or classes representing a step, voice and overlay clip.
   - Provide JSON (or XML) serialization using JUCE's `juce::var`, `DynamicObject` and `ValueTree` utilities.
   - Recreate the preferences structure (sample rate, crossfade time, etc.) with getters and setters.

3. **Implement the DSP Layer**
   - Translate each synth function from `synth_functions` into a C++ class or function that returns a `juce::AudioBuffer<float>` segment.  Many functions rely on sine waves, filters and envelopes; these can be implemented using JUCE’s DSP module (e.g., `dsp::Oscillator`, `dsp::IIR::Filter`) or custom code.
   - Provide transition variants that interpolate parameters over time.  The phase alignment and crossfade routines from `sound_creator.py` will become helper functions operating on `AudioBuffer`s.
   - Handle noise generation and effects such as the flanger using JUCE’s `dsp::NoiseGenerator` or custom algorithms.
   - Implement a safety limiter and normalization step before writing the final file with `juce::WavAudioFormat` or `FlacAudioFormat`.

4. **User Interface in JUCE**
   - Recreate the main editor window with JUCE components (`TreeView`, `TextEditor`, `ComboBox`, `Button`).  The existing PyQt dialogs (voice editor, preferences, noise generator) become separate `Component` classes shown as modal dialogs using `DialogWindow`.
   - Provide step preview playback using `AudioSource` and `AudioTransportSource` so users can audition a single step before exporting the entire track.
   - Use JUCE’s LookAndFeel system to implement the theme support from `ui/themes.py`.
   - Integrate the timeline visualization (currently built with Plotly) using a custom `Component` drawing clips and step ranges.

5. **File and Preset Handling**
   - Replicate noise/voice preset load/save from `utils/voice_file.py` and `utils/noise_file.py` with JUCE’s `File` and `FileChooser`.
   - Provide a simple preferences file stored in the user’s application data directory.
   - Use `juce::AudioFormatReader` to load overlay clips and encode subliminals.

6. **Testing and Validation**
   - Verify that generated audio matches the Python version by comparing waveforms for known sequences.
   - Unit test each synth function in isolation and run integration tests on the track assembly code.
   - Provide a fallback path for any DSP that cannot yet be ported by stubbing the corresponding functions.

## 3. Migration Strategy

1. Start with a minimal JUCE app that can load a sequence JSON and export an audio file using a subset of synthesis functions (e.g. `binaural_beat` and `isochronic_tone`).
2. Incrementally port additional voices, reusing Python as a reference for algorithm correctness.
3. Port the GUI last, after the core engine is stable.  During development, maintain a Python-to-C++ comparison harness.
4. Keep the Python version in the repository for reference until the C++ port is feature complete.

By following this plan the Python project in `src/audio` can be systematically rewritten in C++ with JUCE while preserving existing capabilities.
